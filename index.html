<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Gladia - Live from microphone</title>

    <!-- We are using a 3rd party library to record audio as WAV on every browser. -->
    <!-- Each browser uses its own audio encoding and some of them are not compatible. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/RecordRTC/5.6.2/RecordRTC.js"></script>

    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #f3f4f6;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 1rem;
        box-sizing: border-box;
      }
      .container {
        background-color: #ffffff;
        border-radius: 1rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        padding: 2rem;
        width: 100%;
        max-width: 28rem; /* Equivalent to md:max-w-md */
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      .btn {
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        font-weight: 600;
        transition: background-color 0.2s ease-in-out;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .btn-primary {
        background-color: #4f46e5; /* Indigo 600 */
        color: #ffffff;
      }
      .btn-primary:hover {
        background-color: #4338ca; /* Indigo 700 */
      }
      .btn-danger {
        background-color: #ef4444; /* Red 500 */
        color: #ffffff;
      }
      .btn-danger:hover {
        background-color: #dc2626; /* Red 600 */
      }
      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .input-field {
        width: 100%;
        padding: 0.75rem;
        border-radius: 0.5rem;
        border: 1px solid #d1d5db; /* Gray 300 */
        font-size: 1rem;
      }
      .text-area {
        min-height: 8rem;
        background-color: #f9fafb; /* Gray 50 */
        border: 1px solid #e5e7eb; /* Gray 200 */
        padding: 1rem;
        border-radius: 0.5rem;
        font-size: 0.95rem;
        color: #374151; /* Gray 700 */
        white-space: pre-wrap; /* Preserve whitespace and breaks */
        word-wrap: break-word; /* Break long words */
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="text-2xl font-bold text-gray-800 text-center">
        Live Audio Transcriber
      </h1>
      <form id="form" class="flex flex-col gap-4">
        <div class="flex flex-col gap-2">
          <label for="gladia_key" class="text-gray-700 font-medium"
            >Gladia API key</label
          >
          <input
            id="gladia_key"
            name="gladia_key"
            type="text"
            placeholder="Gladia API key"
            required
            class="input-field"
          />
        </div>
        <div class="flex flex-col gap-2">
          <label for="input_device" class="text-gray-700 font-medium"
            >Audio input device</label
          >
          <select
            id="input_device"
            name="input_device"
            required
            disabled
            class="input-field"
          ></select>
        </div>
        <div class="flex gap-4 justify-center">
          <button type="submit" class="btn btn-primary flex-1">
            Start recording
          </button>
          <button type="button" class="btn btn-danger flex-1" disabled>
            Stop recording
          </button>
        </div>
      </form>

      <div id="result" class="text-area" style="display: none">
        <span id="finals"></span>
        <span style="color: red" id="partials"></span>
      </div>
    </div>

    <script>
      const SAMPLE_RATE = 16000;

      /**
       * @returns {{promise: Promise<any>; resolve(value: any): void; reject(err: any): void;}}
       */
      function deferredPromise() {
        const deferred = {};
        deferred.promise = new Promise((resolve, reject) => {
          deferred.resolve = resolve;
          deferred.reject = reject;
        });
        return deferred;
      }

      // Initialize the audio input devices
      async function listAudioDevices() {
        /** @type {HTMLSelectElement} */
        const inputDeviceSelect = document.querySelector(
          'select[name="input_device"]'
        );

        if (window.location.protocol === "file:") {
          const audioDevices = await navigator.mediaDevices
            .enumerateDevices()
            .then((devices) => devices.filter((d) => d.kind === "audioinput"));
          if (!audioDevices.length) {
            window.alert("No audio input device found");
            return;
          }

          console.log(
            "Cannot list audio input devices since you are running the file locally. We will use your default audio input."
          );
          const option = document.createElement("option");
          option.textContent = "Default";
          option.value = "";
          inputDeviceSelect.appendChild(option);
          inputDeviceSelect.value = "";
          return;
        }

        // Ask the permissions to the user
        const media = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });

        const audioDevices = await navigator.mediaDevices
          .enumerateDevices()
          .then((devices) =>
            devices.filter((d) => d.kind === "audioinput" && d.deviceId)
          );

        // Stop all the tracks now that we have the user permission
        media.getTracks().forEach((track) => track.stop());

        if (!audioDevices.length) {
          window.alert("No audio input device found");
          return;
        }

        inputDeviceSelect.innerHTML = "";
        audioDevices.forEach((device) => {
          const option = document.createElement("option");
          option.value = device.deviceId;
          option.textContent = device.label ?? "Default";
          inputDeviceSelect.appendChild(option);
        });
        inputDeviceSelect.value = audioDevices[0]?.deviceId ?? "";
        inputDeviceSelect.removeAttribute("disabled");
      }
      listAudioDevices();

      async function initiateSession(gladiaKey) {
        const response = await fetch(`https://api.gladia.io/v2/live`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-GLADIA-KEY": gladiaKey,
          },
          body: JSON.stringify({
            sample_rate: SAMPLE_RATE,
          }),
        });
        if (!response.ok) {
          const message =
            `${response.status}: ${(await response.text()) || response.statusText}`;
          throw new Error(message);
        }
        return await response.json();
      }

      /** @type {HTMLFormElement} */
      const form = document.querySelector("#form");
      /** @type {HTMLButtonElement} */
      const submitButton = document.querySelector('button[type="submit"]');
      /** @type {HTMLButtonElement} */
      const stopButton = document.querySelector('button[type="button"]');
      /** @type {HTMLDivElement} */
      const resultContainer = document.querySelector("#result");
      /** @type {HTMLSpanElement} */
      const finalsContainer = document.querySelector("#finals");
      /** @type {HTMLSpanElement} */
      const partialsContainer = document.querySelector("#partials");

      form.addEventListener("submit", async (evt) => {
        evt.preventDefault();

        // Parse submitted data
        const formData = new FormData(form);
        const gladiaKey = formData.get("gladia_key");
        const inputDevice = formData.get("input_device");

        // Update the UI
        submitButton.setAttribute("disabled", "true");
        submitButton.textContent = "Waiting for connection...";
        resultContainer.style.display = "none";
        finalsContainer.textContent = "";
        partialsContainer.textContent = "...";

        /** @type {MediaStream | undefined} */
        let audioStream;
        /** @type {RecordRTC | undefined} */
        let recorder;
        /** @type {WebSocket | undefined} */
        let socket;

        const stop = () => {
          submitButton.removeAttribute("disabled");
          submitButton.textContent = "Start recording";

          stopButton.setAttribute("disabled", "true");
          stopButton.removeEventListener("click", stop);

          recorder?.destroy();
          audioStream?.getTracks().forEach((track) => track.stop());
          if (socket) {
            socket.onopen = null;
            socket.onerror = null;
            socket.onclose = null;
            socket.onmessage = null;
            socket.close();
          }
        };

        try {
          const { url } = await initiateSession(gladiaKey);

          const socketPromise = deferredPromise();

          // Initializes the websocket
          socket = new WebSocket(url);
          socket.onopen = () => {
            socketPromise.resolve(true);
          };
          socket.onerror = () => {
            socketPromise.reject(new Error(`Couldn't connect to the server`));
          };
          socket.onclose = (event) => {
            socketPromise.reject(
              new Error(
                `Server refuses the connection: [${event.code}] ${event.reason}`
              )
            );
          };

          // Get the input stream
          audioStream = await navigator.mediaDevices.getUserMedia({
            audio: inputDevice ? { deviceId: { exact: inputDevice } } : true,
          });

          // Initializes the recorder
          recorder = new RecordRTC(audioStream, {
            type: "audio",
            mimeType: "audio/wav",
            recorderType: RecordRTC.StereoAudioRecorder,
            timeSlice: 1000,
            async ondataavailable(blob) {
              const buffer = await blob.arrayBuffer();
              // Remove WAV header
              const modifiedBuffer = buffer.slice(44);
              socket?.send(modifiedBuffer);
            },
            desiredSampRate: SAMPLE_RATE,
            numberOfAudioChannels: 1,
          });

          await socketPromise.promise;
        } catch (err) {
          window.alert(
            `Error during the initialization: ${err?.message || err}`
          );
          console.error(err);
          stop();
          return;
        }

        // Register new listeners
        socket.onopen = null;
        socket.onerror = null;
        socket.onclose = (event) => {
          const message = `Lost connection to the server: [${event.code}] ${event.reason}`;
          window.alert(message);
          console.error(message);
          stop();
        };
        socket.onmessage = (event) => {
          const message = JSON.parse(event.data);
          console.log(message);
          if (message?.type === "transcript") {
            if (message.data.is_final) {
              finalsContainer.textContent += message.data.utterance.text;
              partialsContainer.textContent = "";
            } else {
              partialsContainer.textContent = message.data.utterance.text;
            }
          }
        };

        submitButton.textContent = "Recording...";

        stopButton.removeAttribute("disabled");
        stopButton.addEventListener("click", stop);

        resultContainer.style.display = "block";

        // Start the recording
        recorder.startRecording();
      });
    </script>
  </body>
</html>